#version 300 es
layout(location = 0) in vec3 inPos;

out vec3 vPosition;

uniform float dT;
uniform sampler2D velocity2D; //The precomputed velocity
uniform int is_track_vert;

float N = 100.0;

float random(vec2 st)
{
    return 2.0*fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123)-1.0;
} 

vec2 TexCoords(vec3 boxcoords){
//Converts between box coordinates and texture coordinates
    float floorFix = 0.000001;
    vec3 newboxcoords = (boxcoords+1.0)/2.0;
    vec2 texcoords = vec2(0.0);

    // Bottom to top then left to right
    texcoords.x = floor(newboxcoords.z * sqrt(N) + floorFix) * 1.0/sqrt(N) + newboxcoords.x * 1.0/sqrt(N);
    texcoords.y = mod(floor(newboxcoords.z * N + floorFix), sqrt(N)) * 1.0/sqrt(N) + newboxcoords.y * 1.0/sqrt(N);
    return texcoords;
}

void main(){

	vec2 texturePos = TexCoords(inPos);
	vec4 u = texture(velocity2D, texturePos); //Calculate the velocity field at this point 
	u += vec4(0.0, 0.0, 0.05, 0.0); //z drift velocity
	
	vPosition = inPos + u.xyz*dT;

    //Background bubbles respawn in the chamber
    if(is_track_vert==0){
        if(abs(vPosition.x)>1.0 || abs(vPosition.y)>1.0 || abs(vPosition.z)>1.0){
    	    float randx = random(vec2(3.1415, vPosition.z)); //Generate random x/y value
    	    float randy = random(vec2(6.6262, vPosition.x));
    	    vPosition = vec3(randx, randy, -1.0);
    	}
    }

    gl_Position = vec4(vPosition.x, vPosition.y, vPosition.z, 1.0);
    gl_PointSize = 10.0;
}
#version 300 es
precision mediump float;

in vec4 fragPos;
out vec4 FragColor;

void main()
{
    FragColor = vec4(abs(fragPos.xyz), 1.0);
}
#version 300 es
layout(location = 0) in vec3 inPos;

out vec4 fragPos;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

vec4 aPos;

void main()
{
    aPos = projection*view*vec4(inPos, 1.0);
    gl_Position = aPos;
    fragPos = vec4(inPos, 1.0);
}
#version 300 es

in vec3 Position;
out vec3 vPosition;
uniform float time;
uniform int is_track_vert;

vec4 permute(vec4 x) {
     vec4 xm = mod(x, 289.0);
     return mod(((xm*34.0)+10.0)*xm, 289.0);
}

float psrdnoise(vec3 x, vec3 period, float alpha, out vec3 gradient)
{

#ifndef PERLINGRID
  // Transformation matrices for the axis-aligned simplex grid
  const mat3 M = mat3(0.0, 1.0, 1.0,
                      1.0, 0.0, 1.0,
                      1.0, 1.0, 0.0);

  const mat3 Mi = mat3(-0.5, 0.5, 0.5,
                        0.5,-0.5, 0.5,
                        0.5, 0.5,-0.5);
#endif

  vec3 uvw;

  // Transform to simplex space (tetrahedral grid)
#ifndef PERLINGRID
  // Use matrix multiplication, let the compiler optimise
  uvw = M * x;
#else
  // Optimised transformation to uvw (slightly faster than
  // the equivalent matrix multiplication on most platforms)
  uvw = x + dot(x, vec3(1.0/3.0));
#endif

  // Determine which simplex we're in, i0 is the "base corner"
  vec3 i0 = floor(uvw);
  vec3 f0 = fract(uvw); // coords within "skewed cube"

  // To determine which simplex corners are closest, rank order the
  // magnitudes of u,v,w, resolving ties in priority order u,v,w,
  // and traverse the four corners from largest to smallest magnitude.
  // o1, o2 are offsets in simplex space to the 2nd and 3rd corners.
  vec3 g_ = step(f0.xyx, f0.yzz); // Makes comparison "less-than"
  vec3 l_ = 1.0 - g_;             // complement is "greater-or-equal"
  vec3 g = vec3(l_.z, g_.xy);
  vec3 l = vec3(l_.xy, g_.z);
  vec3 o1 = min( g, l );
  vec3 o2 = max( g, l );

  // Enumerate the remaining simplex corners
  vec3 i1 = i0 + o1;
  vec3 i2 = i0 + o2;
  vec3 i3 = i0 + vec3(1.0);

  vec3 v0, v1, v2, v3;

  // Transform the corners back to texture space
#ifndef PERLINGRID
  v0 = Mi * i0;
  v1 = Mi * i1;
  v2 = Mi * i2;
  v3 = Mi * i3;
#else
  // Optimised transformation (mostly slightly faster than a matrix)
  v0 = i0 - dot(i0, vec3(1.0/6.0));
  v1 = i1 - dot(i1, vec3(1.0/6.0));
  v2 = i2 - dot(i2, vec3(1.0/6.0));
  v3 = i3 - dot(i3, vec3(1.0/6.0));
#endif

  // Compute vectors to each of the simplex corners
  vec3 x0 = x - v0;
  vec3 x1 = x - v1;
  vec3 x2 = x - v2;
  vec3 x3 = x - v3;

  if(any(greaterThan(period, vec3(0.0)))) {
    // Wrap to periods and transform back to simplex space
    vec4 vx = vec4(v0.x, v1.x, v2.x, v3.x);
    vec4 vy = vec4(v0.y, v1.y, v2.y, v3.y);
    vec4 vz = vec4(v0.z, v1.z, v2.z, v3.z);
	// Wrap to periods where specified
	if(period.x > 0.0) vx = mod(vx, period.x);
	if(period.y > 0.0) vy = mod(vy, period.y);
	if(period.z > 0.0) vz = mod(vz, period.z);
    // Transform back
#ifndef PERLINGRID
    i0 = M * vec3(vx.x, vy.x, vz.x);
    i1 = M * vec3(vx.y, vy.y, vz.y);
    i2 = M * vec3(vx.z, vy.z, vz.z);
    i3 = M * vec3(vx.w, vy.w, vz.w);
#else
    v0 = vec3(vx.x, vy.x, vz.x);
    v1 = vec3(vx.y, vy.y, vz.y);
    v2 = vec3(vx.z, vy.z, vz.z);
    v3 = vec3(vx.w, vy.w, vz.w);
    // Transform wrapped coordinates back to uvw
    i0 = v0 + dot(v0, vec3(1.0/3.0));
    i1 = v1 + dot(v1, vec3(1.0/3.0));
    i2 = v2 + dot(v2, vec3(1.0/3.0));
    i3 = v3 + dot(v3, vec3(1.0/3.0));
#endif
	// Fix rounding errors
    i0 = floor(i0 + 0.5);
    i1 = floor(i1 + 0.5);
    i2 = floor(i2 + 0.5);
    i3 = floor(i3 + 0.5);
  }

  // Compute one pseudo-random hash value for each corner
  vec4 hash = permute( permute( permute( 
              vec4(i0.z, i1.z, i2.z, i3.z ))
            + vec4(i0.y, i1.y, i2.y, i3.y ))
            + vec4(i0.x, i1.x, i2.x, i3.x ));

  // Compute generating gradients from a Fibonacci spiral on the unit sphere
  vec4 theta = hash * 3.883222077;  // 2*pi/golden ratio
  vec4 sz    = hash * -0.006920415 + 0.996539792; // 1-(hash+0.5)*2/289
  vec4 psi   = hash * 0.108705628 ; // 10*pi/289, chosen to avoid correlation

  vec4 Ct = cos(theta);
  vec4 St = sin(theta);
  vec4 sz_prime = sqrt( 1.0 - sz*sz ); // s is a point on a unit fib-sphere

  vec4 gx, gy, gz;

  // Rotate gradients by angle alpha around a pseudo-random ortogonal axis
#ifdef FASTROTATION
  // Fast algorithm, but without dynamic shortcut for alpha = 0
  vec4 qx = St;         // q' = norm ( cross(s, n) )  on the equator
  vec4 qy = -Ct; 
  vec4 qz = vec4(0.0);

  vec4 px =  sz * qy;   // p' = cross(q, s)
  vec4 py = -sz * qx;
  vec4 pz = sz_prime;

  psi += alpha;         // psi and alpha in the same plane
  vec4 Sa = sin(psi);
  vec4 Ca = cos(psi);

  gx = Ca * px + Sa * qx;
  gy = Ca * py + Sa * qy;
  gz = Ca * pz + Sa * qz;
#else
  // Slightly slower algorithm, but with g = s for alpha = 0, and a
  // useful conditional speedup for alpha = 0 across all fragments
  if(alpha != 0.0) {
    vec4 Sp = sin(psi);          // q' from psi on equator
    vec4 Cp = cos(psi);

    vec4 px = Ct * sz_prime;     // px = sx
    vec4 py = St * sz_prime;     // py = sy
    vec4 pz = sz;

    vec4 Ctp = St*Sp - Ct*Cp;    // q = (rotate( cross(s,n), dot(s,n))(q')
    vec4 qx = mix( Ctp*St, Sp, sz);
    vec4 qy = mix(-Ctp*Ct, Cp, sz);
    vec4 qz = -(py*Cp + px*Sp);

    vec4 Sa = vec4(sin(alpha));       // psi and alpha in different planes
    vec4 Ca = vec4(cos(alpha));

    gx = Ca * px + Sa * qx;
    gy = Ca * py + Sa * qy;
    gz = Ca * pz + Sa * qz;
  }
  else {
    gx = Ct * sz_prime;  // alpha = 0, use s directly as gradient
    gy = St * sz_prime;
    gz = sz;  
  }
#endif

  // Reorganize for dot products below
  vec3 g0 = vec3(gx.x, gy.x, gz.x);
  vec3 g1 = vec3(gx.y, gy.y, gz.y);
  vec3 g2 = vec3(gx.z, gy.z, gz.z);
  vec3 g3 = vec3(gx.w, gy.w, gz.w);

  // Radial decay with distance from each simplex corner
  vec4 w = 0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3));
  w = max(w, 0.0);
  vec4 w2 = w * w;
  vec4 w3 = w2 * w;

  // The value of the linear ramp from each of the corners
  vec4 gdotx = vec4(dot(g0,x0), dot(g1,x1), dot(g2,x2), dot(g3,x3));

  // Multiply by the radial decay and sum up the noise value
  float n = dot(w3, gdotx);

  // Compute the first order partial derivatives
  vec4 dw = -6.0 * w2 * gdotx;
  vec3 dn0 = w3.x * g0 + dw.x * x0;
  vec3 dn1 = w3.y * g1 + dw.y * x1;
  vec3 dn2 = w3.z * g2 + dw.z * x2;
  vec3 dn3 = w3.w * g3 + dw.w * x3;
  gradient = 39.5 * (dn0 + dn1 + dn2 + dn3);

  // Scale the return value to fit nicely into the range [-1,1]
  return 39.5 * n;
}

vec3 p1 = vec3(0.0, 0.0, 0.0);
vec3 p2 = vec3(0.0, 0.0, 0.0);
vec3 p3 = vec3(0.0, 0.0, 0.0);    

float fbm(vec3 pos, float alpha, out vec3 grad)
{
    int N = 6;

    vec3 p = vec3(0.0);
    float w = 1.0; //Weight of noise
    float s = 2.0; //Scale of noise
    float n = 0.0; //Output noise value

    vec3 g;
    vec3 gsum = vec3(0.0);

    for(int i = 0; i<N ; i++){
        n += w * psrdnoise(s*pos + 0.13*gsum, p, s*alpha, g);
        gsum += w*g;
        s *= 2.0;
        w *= pow(s,-1.0/3.0);
    }

    grad = gsum;
    return n;

}

vec3 offset2 = vec3(1000.0, 0.0, 0.0);
vec3 offset3 = vec3(0.0, 0.0, 1000.0);

vec3 curlnoise(vec3 pos, float alpha)
{


    vec3 grad1;
    vec3 grad2;
    vec3 grad3;
    float n1 = fbm(pos, alpha, grad1);
    float n2 = fbm(pos+offset2, alpha, grad2);
    float n3 = fbm(pos+offset3, alpha, grad3);

    float w = sqrt(n1*n1 + n2*n2 + n3*n3);

    vec3 velocity = w*vec3((grad3.y-grad2.z),(grad1.z-grad3.x),(grad2.x-grad1.y));

    return velocity;

}

float random(vec2 st)
{
    return 2.0*fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123)-1.0;
} 

void main()
{
    //Only update positions if vertex is in the box
    if(abs(vPosition.x)<1.0 || abs(vPosition.y)<1.0){
	float alpha = 0.1*time;
    	vec3 velocity = curlnoise(Position, alpha);
    	//velocity = normalise(velocity);
    	vec3 drift = vec3(0.0, 0.0, 0.0008);
    	vPosition = Position + 0.0001*velocity + drift;
    }
    
    //Background bubbles respawn in the chamber
    if(is_track_vert==0){
        if(abs(vPosition.x)>1.0 || abs(vPosition.y)>1.0 || abs(vPosition.z)>1.0){
    	    float randx = random(vec2(3.1415, vPosition.z)); //Generate random x/y value
    	    float randy = random(vec2(6.6262, vPosition.x));
    	    vPosition = vec3(randx, randy, 0.9);
    	}
    }

    gl_Position = vec4(vPosition.x, vPosition.y, vPosition.z, 1.0);
    gl_PointSize = 10.0;
}
#version 300 es
precision mediump float;

in vec4 fragPos;
in vec2 texCoords;
out vec4 FragColor;

uniform mediump sampler2D backgroundTexture; // The framebuffer's color texture
uniform mediump sampler2D cloudTexture;  // The depth texture

vec3 lightColour = vec3(1.0);

float screenWidth = 1080.0;
float screenHeight = 720.0;

const int kernelSize = 9;
const float sigma = 2.0; // Adjust this for the desired blur amount

float gaussian(float x, float sigma) {
    return exp(-(x * x) / (2.0 * sigma * sigma)) / (sqrt(2.0 * 3.14159265358979323846) * sigma);
}

vec4 gaussianClouds() {
    vec2 texelSize = 1.0 / vec2(screenWidth, screenHeight);

    // Gaussian kernel values
    float kernel[kernelSize];
    float totalWeight = 0.0;

    for (int i = 0; i < kernelSize; ++i) {
        float offset = float(i - (kernelSize - 1) / 2);
        kernel[i] = gaussian(offset, sigma);
        totalWeight += kernel[i];
    }

    // Normalize the kernel
    for (int i = 0; i < kernelSize; ++i) {
        kernel[i] /= totalWeight;
    }

    vec4 result = vec4(0.0);

    // Apply the convolution
    for (int i = 0; i < kernelSize; ++i) {
        for (int j = 0; j < kernelSize; ++j) {
            vec2 texP = texCoords + texelSize * vec2(float(i) - (float(kernelSize) - 1.0) / 2.0, float(j) - (float(kernelSize) - 1.0) / 2.0);
            result += texture(cloudTexture, texP) * kernel[i] * kernel[j];
        }
    }
    
    return result;
}

void main() {
    vec4 backTex = texture(backgroundTexture, texCoords);
    vec4 clouds = gaussianClouds();
    // vec4 clouds = texture(cloudTexture, texCoords);
    

    float lightEnergy = clouds.x;
    float transmittance = clouds.y;
    float lampIntensity = clouds.z;

    vec3 cloudCol = lightEnergy * lightColour;
    vec3 col = backTex.xyz*transmittance + cloudCol + lampIntensity*transmittance;

    // backTex = backTex*clouds.w;
    // backTex.xyz = backTex.xyz + clouds.xyz;

    // vec3 outCol = backTex.xyz+clouds;
    FragColor = vec4(col, 0.0);
    // FragColor = vec4(clouds);
}
#version 300 es
layout(location = 0) in vec3 inPos;

out vec4 fragPos;
out vec2 texCoords;

void main()
{
    vec4 aPos = vec4(inPos, 1.0);
    gl_Position = aPos;
    fragPos = aPos;

    texCoords = (inPos.xy + vec2(1.0)) / 2.0;
}
#version 300 es

//
// psrdnoise3.glsl
//
// Authors: Stefan Gustavson (stefan.gustavson@gmail.com)
// and Ian McEwan (ijm567@gmail.com)
// Version 2021-12-02, published under the MIT license (see below)
//
// Copyright (c) 2021 Stefan Gustavson and Ian McEwan.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//

//
// Periodic (tiling) 3-D simplex noise (tetrahedral lattice gradient noise)
// with rotating gradients and analytic derivatives.
//
// This is (yet) another variation on simplex noise. Unlike previous
// implementations, the grid is axis-aligned to permit rectangular tiling.
// The noise pattern can be made to tile seamlessly to any integer periods
// up to 289 units in the x, y and z directions. Specifying a longer
// period than 289 will result in errors in the noise field.
//
// This particular version of 3-D noise also implements animation by rotating
// the generating gradient at each lattice point around a pseudo-random axis.
// The rotating gradients give the appearance of a swirling motion, and
// can serve a similar purpose for animation as motion along the fourth
// dimension in 4-D noise. 
//
// The rotating gradients in conjunction with the built-in ability to
// compute exact analytic derivatives allow for "flow noise" effects
// as presented by Ken Perlin and Fabrice Neyret.
//

// Use Perlin's rotated grid instead of the new tiling grid?
// Enabling this adds about 1% to the execution time and
// requires all periods to be multiples of 3. Other
// integer periods can be specified, but when not evenly
// divisible by 3, the actual period will be 3 times longer.
// Take care not to overstep the maximum allowed period (288).
//#define PERLINGRID

// Enable faster gradient rotations?
// Enabling this saves about 10% on execution time,
// but the function will not run faster for alpha = 0.
//#define FASTROTATION


// Permutation polynomial for the hash value
vec4 permute(vec4 x) {
     vec4 xm = mod(x, 289.0);
     return mod(((xm*34.0)+10.0)*xm, 289.0);
}

//
// 3-D tiling simplex noise with rotating gradients and first order
// analytical derivatives.
// "vec3 x" is the point (x,y,z) to evaluate
// "vec3 period" is the desired periods along x,y,z, up to 289.
// (If Perlin's grid is used, multiples of 3 up to 288 are allowed.)
// "float alpha" is the rotation (in radians) for the swirling gradients.
// The "float" return value is the noise value, and
// the "out vec3 gradient" argument returns the x,y,z partial derivatives.
//
// The function executes 15-20% faster if alpha is constant == 0.0
// across all fragments being executed in parallel.
// (This speedup will not happen if FASTROTATION is enabled. Do not specify
// FASTROTATION if you are not actually going to use the rotation.)
//
// Setting any period to 0.0 or a negative value will skip the periodic
// wrap for that dimension. Setting all periods to 0.0 makes the function
// execute 10-15% faster.
//
// Not using the return value for the gradient will make the compiler
// eliminate the code for computing it. This speeds up the function by
// around 10%.
//
float psrdnoise(vec3 x, vec3 period, float alpha, out vec3 gradient)
{

#ifndef PERLINGRID
  // Transformation matrices for the axis-aligned simplex grid
  const mat3 M = mat3(0.0, 1.0, 1.0,
                      1.0, 0.0, 1.0,
                      1.0, 1.0, 0.0);

  const mat3 Mi = mat3(-0.5, 0.5, 0.5,
                        0.5,-0.5, 0.5,
                        0.5, 0.5,-0.5);
#endif

  vec3 uvw;

  // Transform to simplex space (tetrahedral grid)
#ifndef PERLINGRID
  // Use matrix multiplication, let the compiler optimise
  uvw = M * x;
#else
  // Optimised transformation to uvw (slightly faster than
  // the equivalent matrix multiplication on most platforms)
  uvw = x + dot(x, vec3(1.0/3.0));
#endif

  // Determine which simplex we're in, i0 is the "base corner"
  vec3 i0 = floor(uvw);
  vec3 f0 = fract(uvw); // coords within "skewed cube"

  // To determine which simplex corners are closest, rank order the
  // magnitudes of u,v,w, resolving ties in priority order u,v,w,
  // and traverse the four corners from largest to smallest magnitude.
  // o1, o2 are offsets in simplex space to the 2nd and 3rd corners.
  vec3 g_ = step(f0.xyx, f0.yzz); // Makes comparison "less-than"
  vec3 l_ = 1.0 - g_;             // complement is "greater-or-equal"
  vec3 g = vec3(l_.z, g_.xy);
  vec3 l = vec3(l_.xy, g_.z);
  vec3 o1 = min( g, l );
  vec3 o2 = max( g, l );

  // Enumerate the remaining simplex corners
  vec3 i1 = i0 + o1;
  vec3 i2 = i0 + o2;
  vec3 i3 = i0 + vec3(1.0);

  vec3 v0, v1, v2, v3;

  // Transform the corners back to texture space
#ifndef PERLINGRID
  v0 = Mi * i0;
  v1 = Mi * i1;
  v2 = Mi * i2;
  v3 = Mi * i3;
#else
  // Optimised transformation (mostly slightly faster than a matrix)
  v0 = i0 - dot(i0, vec3(1.0/6.0));
  v1 = i1 - dot(i1, vec3(1.0/6.0));
  v2 = i2 - dot(i2, vec3(1.0/6.0));
  v3 = i3 - dot(i3, vec3(1.0/6.0));
#endif

  // Compute vectors to each of the simplex corners
  vec3 x0 = x - v0;
  vec3 x1 = x - v1;
  vec3 x2 = x - v2;
  vec3 x3 = x - v3;

  if(any(greaterThan(period, vec3(0.0)))) {
    // Wrap to periods and transform back to simplex space
    vec4 vx = vec4(v0.x, v1.x, v2.x, v3.x);
    vec4 vy = vec4(v0.y, v1.y, v2.y, v3.y);
    vec4 vz = vec4(v0.z, v1.z, v2.z, v3.z);
	// Wrap to periods where specified
	if(period.x > 0.0) vx = mod(vx, period.x);
	if(period.y > 0.0) vy = mod(vy, period.y);
	if(period.z > 0.0) vz = mod(vz, period.z);
    // Transform back
#ifndef PERLINGRID
    i0 = M * vec3(vx.x, vy.x, vz.x);
    i1 = M * vec3(vx.y, vy.y, vz.y);
    i2 = M * vec3(vx.z, vy.z, vz.z);
    i3 = M * vec3(vx.w, vy.w, vz.w);
#else
    v0 = vec3(vx.x, vy.x, vz.x);
    v1 = vec3(vx.y, vy.y, vz.y);
    v2 = vec3(vx.z, vy.z, vz.z);
    v3 = vec3(vx.w, vy.w, vz.w);
    // Transform wrapped coordinates back to uvw
    i0 = v0 + dot(v0, vec3(1.0/3.0));
    i1 = v1 + dot(v1, vec3(1.0/3.0));
    i2 = v2 + dot(v2, vec3(1.0/3.0));
    i3 = v3 + dot(v3, vec3(1.0/3.0));
#endif
	// Fix rounding errors
    i0 = floor(i0 + 0.5);
    i1 = floor(i1 + 0.5);
    i2 = floor(i2 + 0.5);
    i3 = floor(i3 + 0.5);
  }

  // Compute one pseudo-random hash value for each corner
  vec4 hash = permute( permute( permute( 
              vec4(i0.z, i1.z, i2.z, i3.z ))
            + vec4(i0.y, i1.y, i2.y, i3.y ))
            + vec4(i0.x, i1.x, i2.x, i3.x ));

  // Compute generating gradients from a Fibonacci spiral on the unit sphere
  vec4 theta = hash * 3.883222077;  // 2*pi/golden ratio
  vec4 sz    = hash * -0.006920415 + 0.996539792; // 1-(hash+0.5)*2/289
  vec4 psi   = hash * 0.108705628 ; // 10*pi/289, chosen to avoid correlation

  vec4 Ct = cos(theta);
  vec4 St = sin(theta);
  vec4 sz_prime = sqrt( 1.0 - sz*sz ); // s is a point on a unit fib-sphere

  vec4 gx, gy, gz;

  // Rotate gradients by angle alpha around a pseudo-random ortogonal axis
#ifdef FASTROTATION
  // Fast algorithm, but without dynamic shortcut for alpha = 0
  vec4 qx = St;         // q' = norm ( cross(s, n) )  on the equator
  vec4 qy = -Ct; 
  vec4 qz = vec4(0.0);

  vec4 px =  sz * qy;   // p' = cross(q, s)
  vec4 py = -sz * qx;
  vec4 pz = sz_prime;

  psi += alpha;         // psi and alpha in the same plane
  vec4 Sa = sin(psi);
  vec4 Ca = cos(psi);

  gx = Ca * px + Sa * qx;
  gy = Ca * py + Sa * qy;
  gz = Ca * pz + Sa * qz;
#else
  // Slightly slower algorithm, but with g = s for alpha = 0, and a
  // useful conditional speedup for alpha = 0 across all fragments
  if(alpha != 0.0) {
    vec4 Sp = sin(psi);          // q' from psi on equator
    vec4 Cp = cos(psi);

    vec4 px = Ct * sz_prime;     // px = sx
    vec4 py = St * sz_prime;     // py = sy
    vec4 pz = sz;

    vec4 Ctp = St*Sp - Ct*Cp;    // q = (rotate( cross(s,n), dot(s,n))(q')
    vec4 qx = mix( Ctp*St, Sp, sz);
    vec4 qy = mix(-Ctp*Ct, Cp, sz);
    vec4 qz = -(py*Cp + px*Sp);

    vec4 Sa = vec4(sin(alpha));       // psi and alpha in different planes
    vec4 Ca = vec4(cos(alpha));

    gx = Ca * px + Sa * qx;
    gy = Ca * py + Sa * qy;
    gz = Ca * pz + Sa * qz;
  }
  else {
    gx = Ct * sz_prime;  // alpha = 0, use s directly as gradient
    gy = St * sz_prime;
    gz = sz;  
  }
#endif

  // Reorganize for dot products below
  vec3 g0 = vec3(gx.x, gy.x, gz.x);
  vec3 g1 = vec3(gx.y, gy.y, gz.y);
  vec3 g2 = vec3(gx.z, gy.z, gz.z);
  vec3 g3 = vec3(gx.w, gy.w, gz.w);

  // Radial decay with distance from each simplex corner
  vec4 w = 0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3));
  w = max(w, 0.0);
  vec4 w2 = w * w;
  vec4 w3 = w2 * w;

  // The value of the linear ramp from each of the corners
  vec4 gdotx = vec4(dot(g0,x0), dot(g1,x1), dot(g2,x2), dot(g3,x3));

  // Multiply by the radial decay and sum up the noise value
  float n = dot(w3, gdotx);

  // Compute the first order partial derivatives
  vec4 dw = -6.0 * w2 * gdotx;
  vec3 dn0 = w3.x * g0 + dw.x * x0;
  vec3 dn1 = w3.y * g1 + dw.y * x1;
  vec3 dn2 = w3.z * g2 + dw.z * x2;
  vec3 dn3 = w3.w * g3 + dw.w * x3;
  gradient = 39.5 * (dn0 + dn1 + dn2 + dn3);

  // Scale the return value to fit nicely into the range [-1,1]
  return 39.5 * n;
}

precision mediump float;

in float inValue;
out float outValue;

void main()
{
    vec3 x = vec3(0.0, 0.0, 0.0);
    vec3 p = vec3(0.0, 0.0, 0.0);
    float alpha = 0.0;
    vec3 grad;
    psrdnoise(x,p,alpha,grad);
    outValue = inValue;
}

#version 300 es
precision mediump float;

in vec3 fragPos;
out vec4 FragColor;

float lightCentreZ = 0.0;
float lightStd = 0.2;

// Simulate light being produced in a strip
float lightBeamFactor(vec3 rayPos) {
    float x = rayPos.z;
    float gaussian = exp(-((x - lightCentreZ) * (x - lightCentreZ)) / (2.0 * lightStd * lightStd));
    return gaussian;
}

void main()
{
    float luminocity = lightBeamFactor(fragPos);

    FragColor = vec4(luminocity, luminocity, luminocity, 0.0);
    // FragColor = vec4(fragPos, luminocity);
}
#version 300 es
layout(location = 0) in vec3 quad;
layout(location = 1) in vec3 particlePos;

out vec3 fragPos;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

vec3 aPos;

void main()
{
    aPos = quad*0.001 + particlePos;
    gl_Position = projection*view*vec4(aPos, 1.0);

    // gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);
    // fragPos = vec3(abs(view[0][0]), abs(view[1][1]), abs(view[2][2]));//particlePos;
    fragPos = particlePos;//particlePos;
}
#version 300 es
precision mediump float;

in vec4 fragPos;
in vec2 texCoords;
out vec4 FragColor;

uniform mediump sampler3D texture3D; // Cloud texture
uniform sampler2D framebufferColorTexture; // The framebuffer's color texture
uniform sampler2D framebufferDepthTexture;  // The depth texture

uniform float time;
uniform float texDim;
uniform float nearClip;
uniform float farClip;
uniform float fovRad;

uniform vec3 lightPos;
uniform vec3 minPos;
uniform vec3 maxPos;

uniform mat4 view;

const float PI = 3.14159265359;
const float threshold = 0.0;

float maxTransmissionSamples = 120.0;
float maxLightSamples = 6.0;
float light_fine_step_size = 0.02;
float coarse_step_multiplier = 3.0;
int reset_step_count = 4;


float lightFactor = 10.0;
float fogFactor = 10.0;
float lightCentreZ = 0.0;
float lightStd = 0.2;

vec3 boundingCubeMin = -1.0*vec3(1.0);
vec3 boundingCubeMax = vec3(1.0);

struct Intersection {
    float tNear;
    float tFar;
    bool intersectFound;
    vec3 minIntersect;
    vec3 maxIntersect;
};


float depthToDistance(float depth) {
    float ndcDepth = 2.0 * depth - 1.0;
    float viewSpaceDepth = (2.0 * nearClip * farClip) / (farClip + nearClip - ndcDepth * (farClip - nearClip));
    return viewSpaceDepth;
}

float getDepth(vec3 ro, vec3 rd) {
    vec3 rayLenWorld = rd-ro;
    // vec4 rayLenWorld4 = vec4(rayLenWorld, 0.0);
    vec3 rayLenCam = mat3(view) * rayLenWorld;
    return abs(rayLenCam.z);
}

float getCamDepth(float fovRad) {
    return 1.0/tan(fovRad/2.0);
}

float getTCurrent(vec3 rayOrigin, vec3 rayDirection, vec3 rayPosition) {
    float tCurrent = -999999.0;

    for (int i = 0; i < 3; i++) {
        float t1 = (rayPosition[i] - rayOrigin[i]) / rayDirection[i];
        
        tCurrent = max(tCurrent, t1);
    }

    return tCurrent;
}

// Used to determine where ray enters and exits cloud box
Intersection rayCubeIntersectionPoints(vec3 rayOrigin, vec3 rayDirection, vec3 minVertex, vec3 maxVertex) {
    float tNear = -999999.0;  // A very small negative value
    float tFar = 999999.0;    // A very large positive value
    Intersection intersect;
    intersect.intersectFound = false;
    intersect.tNear = tNear;
    intersect.tFar = tFar;
    intersect.minIntersect = vec3(0.0);
    intersect.maxIntersect = vec3(0.0);

    for (int i = 0; i < 3; i++) {
        float t1 = (minVertex[i] - rayOrigin[i]) / rayDirection[i];
        float t2 = (maxVertex[i] - rayOrigin[i]) / rayDirection[i];
        
        tNear = max(tNear, min(t1, t2));
        tFar = min(tFar, max(t1, t2));
    }

    if (tNear <= tFar && tFar > 0.0) {
        intersect.intersectFound = true;
        intersect.tNear = tNear;
        intersect.tFar = tFar;
        intersect.minIntersect = rayOrigin + tNear * rayDirection;
        intersect.maxIntersect = rayOrigin + tFar * rayDirection;
        return intersect;
    }

    return intersect;  // No intersection; you can return any sentinel value
}

// SDF for track bounding boxes
float sdfCuboid(vec3 p, vec3 minCorner, vec3 maxCorner)
{
    vec3 c = (minCorner + maxCorner) * 0.5;;
    vec3 s = (maxCorner - minCorner);
    float x = max
    (   p.x - c.x - s.x / 2.,
        c.x - p.x - s.x / 2.
    );
    float y = max
    (   p.y - c.y - s.y / 2.,
        c.y - p.y - s.y / 2.
    );
    
    float z = max
    (   p.z - c.z - s.z / 2.,
        c.z - p.z - s.z / 2.
    );
    float d = x;
    d = max(d,y);
    d = max(d,z);
    return d;
}

// Need to move this into a world function
float get_texture(in vec3 pos) 
{
    // return sphereTexture(pos);
    if (sdfCuboid(pos, boundingCubeMin, boundingCubeMax) < 0.0) {
        vec3 stepSize = (maxPos - minPos) / (texDim-1.0); // texture dim - 1 add as uniform
        vec3 texCoords3D = (pos-minPos) / (stepSize*texDim);
        vec4 denvec = texture(texture3D, texCoords3D);
        float den = denvec.r;
        if (den < threshold) {
            den = 0.0;
        }
        return den*0.1;
    }
    return 0.0;
}

// To help avoid banding
float randomStepModifier(vec2 st) {
    return max(0.5, fract(sin(dot(st, vec2(12.9898, 78.233)) * 43758.5453)))/10.0 + 0.9;
}

float angleBetween(vec3 vectorA, vec3 vectorB) {
    vec3 normalizedA = normalize(vectorA);
    vec3 normalizedB = normalize(vectorB);
    float dotProduct = dot(normalizedA, normalizedB);
    
    float angle = acos(dotProduct);

    return angle;
}

// Anisotropic light scattering
float phaseFun(in float theta) {
    float g = 0.3;
    float phase = (1.0-pow(g, 2.0)) / pow(1.0 + pow(g, 2.0) - 2.0*g*cos(theta+PI/2.0), 3.0/2.0);
    return phase;
}

// Simulate light being produced in a strip
float lightBeamFactor(vec3 rayPos) {
    float x = rayPos.z;
    float gaussian = exp(-((x - lightCentreZ) * (x - lightCentreZ)) / (2.0 * lightStd * lightStd));
    return gaussian;
}

// Raycast back to light source
float lightMarch(in vec3 rayPosition) {
    vec3 lightDir = normalize(lightPos-rayPosition);
    vec3 position = rayPosition;

    float fine_step = light_fine_step_size;//(intersect.tFar-tCurrent) / maxLightSamples;
    float step = fine_step;

    float step_size_icrement = (coarse_step_multiplier-1.0)*fine_step/maxLightSamples;

    float subDen = 0.0;
    float sub_den_tmp = 0.0;

    // Increase light step distance each step
    for (int j=0; j<int(maxLightSamples); j++) {
        // Check whether light ray has left the cloud box

        float random_step = randomStepModifier(rayPosition.xy);
        position += lightDir*step*random_step;
        sub_den_tmp = get_texture(position);
        
        subDen += sub_den_tmp*step*random_step;

        step += step_size_icrement;
    }

    float transmittance = exp(-subDen);
    return transmittance;
}

// Ray March/cast to/into fog
vec4 ray_march(in vec3 ro, in vec3 rd)
{
    vec3 rayPosition = ro;

    float transmittance = 1.0;
    float lightEnergy = 0.0;

    bool is_coarse = true;
    int coarse_countdown = 0;

    // Used to draw light location
    float lampIntensity = 0.0;
    float backgroundDepth = depthToDistance(texture(framebufferDepthTexture, texCoords).x);

    // Determine distance to traverse cloud box
    Intersection intersect = rayCubeIntersectionPoints(ro, rd, minPos, maxPos);

    if (intersect.intersectFound) {
        // if outside cloudbox then start ray at edge of cloud box
        float fine_step;
        if (intersect.tNear > 0.0) {
            rayPosition = intersect.minIntersect;
            fine_step = (intersect.tFar-intersect.tNear) / maxTransmissionSamples;
        } else {
            float tCurrent = getTCurrent(ro, rd, rayPosition);
            fine_step = (intersect.tFar-tCurrent) / maxTransmissionSamples;
        }

        float step = fine_step*coarse_step_multiplier;

        for (int i = 0; i < int(maxTransmissionSamples); i++) {
            // Check if ray has left cloud box
            float tCurrent = getTCurrent(ro, rd, rayPosition);
            if (tCurrent > intersect.tFar) {
                break;
            }

            // Update position with random step to avoid banding
            float random_step = randomStepModifier(rayPosition.xy);
            rayPosition += rd*step*random_step;

            // Stop if hits background bubble
            if (getDepth(ro, rayPosition) > backgroundDepth) {
                break;
            }

            float density = get_texture(rayPosition);
            if (density > 0.4 && is_coarse) {
                rayPosition -= rd*step*random_step;
                step = fine_step;
                rayPosition += rd*step*random_step;
                density = get_texture(rayPosition);
                coarse_countdown = reset_step_count;
                is_coarse = false;
            } else if (density < 0.4 && coarse_countdown > 0) {
                coarse_countdown --;
            }

            if (coarse_countdown == 0 && !is_coarse) {
                step = coarse_step_multiplier*fine_step;
                is_coarse = true;
            }

            // Get light scattering factor
            vec3 lightDir = lightPos-rayPosition;
            float theta =  angleBetween(lightDir, rd) ;
            float phase = phaseFun(theta);
            float lightBeamMult = lightBeamFactor(rayPosition);

            // Get light energy and opacity
            if (density > 0.01) {
                float lightTransmittance = lightMarch(rayPosition);
                float cloud_retro_reflectance = 1.0 - exp(-density*step);
                lightEnergy += lightFactor * density * step * transmittance * (lightTransmittance+cloud_retro_reflectance) * phase * lightBeamMult;
                transmittance *= exp(-density * step * fogFactor);
            } else {
                // Draw lamp location on screen
                if (angleBetween(rd, lightPos) < 0.01) {
                    lampIntensity += 1.0*step;
                }
            }

            if (transmittance < 0.01) {
                break;
            }
        }
    }

    return vec4(lightEnergy, transmittance, lampIntensity, 0.0);
}

void main()
{
    mat4 invertView = inverse(view);
    vec4 camera_position = invertView*vec4(0.0, 0.0, 0.0, 1.0);
    vec4 ro = camera_position;
    vec4 mFragPos = fragPos;
    mFragPos.z = -getCamDepth(fovRad);
    vec3 rd = normalize((invertView*mFragPos - camera_position).xyz);
    FragColor = vec4(0.0);

    vec4 shaded_color = ray_march(ro.xyz, rd.xyz);
    FragColor = shaded_color;

    // vec3 p = fragPos.xyz;
    // p.z = time*p.z*10.0;

    // FragColor = abs(rd);

    // float depthCol = texture(framebufferDepthTexture, texCoords).x;
    // FragColor = vec4(vec3(depthToDistance(depthCol)), 1.0);
    // vec4 pixCol = texture(framebufferColorTexture, (fragPos.xy + vec2(1.0))/2.0);
    // FragColor = texture(framebufferColorTexture, texCoords);
    // FragColor = vec4(1.0);
    // FragColor = shaded_color;
    // FragColor = texture(texture3D, p);
    // FragColor = vec4(abs(maxPos), 1.0);
}
#version 300 es
layout(location = 0) in vec3 quad;
// layout(location = 1) in vec3 particlePos;

out vec4 fragPos;
out vec2 texCoords;

// uniform mat4 model;
// uniform mat4 view;
uniform mat4 projection;
uniform float aspect;

vec4 aPos;

void main()
{
    aPos = vec4(quad, 1.0);
    gl_Position = aPos;
    // aPos.x = aPos.x;
    aPos.x = aspect*aPos.x;
    // vec4 aPos4 = view*vec4(aPos, 1.0);

    fragPos = aPos;//particlePos;
    texCoords = (quad.xy + vec2(1.0)) / 2.0;
}
#version 300 es

in float inValue;
out float outValue;

void main()
{
    outValue = sqrt(inValue);
}
#version 300 es

in vec3 Position;
out vec3 vPosition;
uniform float time;

void main()
{
    vPosition = Position;
    gl_Position = vec4(vPosition.x, vPosition.y, vPosition.z, 1.0);
    gl_PointSize = 10.0;
}
#version 300 es
precision mediump float;

in vec3 fragPos;
out vec4 FragColor;
uniform float t;

vec4 permute(vec4 x) {
     vec4 xm = mod(x, 289.0);
     return mod(((xm*34.0)+10.0)*xm, 289.0);
}

float psrdnoise(vec3 x, vec3 period, float alpha, out vec3 gradient)
{

#ifndef PERLINGRID
  // Transformation matrices for the axis-aligned simplex grid
  const mat3 M = mat3(0.0, 1.0, 1.0,
                      1.0, 0.0, 1.0,
                      1.0, 1.0, 0.0);

  const mat3 Mi = mat3(-0.5, 0.5, 0.5,
                        0.5,-0.5, 0.5,
                        0.5, 0.5,-0.5);
#endif

  vec3 uvw;

  // Transform to simplex space (tetrahedral grid)
#ifndef PERLINGRID
  // Use matrix multiplication, let the compiler optimise
  uvw = M * x;
#else
  // Optimised transformation to uvw (slightly faster than
  // the equivalent matrix multiplication on most platforms)
  uvw = x + dot(x, vec3(1.0/3.0));
#endif

  // Determine which simplex we're in, i0 is the "base corner"
  vec3 i0 = floor(uvw);
  vec3 f0 = fract(uvw); // coords within "skewed cube"

  // To determine which simplex corners are closest, rank order the
  // magnitudes of u,v,w, resolving ties in priority order u,v,w,
  // and traverse the four corners from largest to smallest magnitude.
  // o1, o2 are offsets in simplex space to the 2nd and 3rd corners.
  vec3 g_ = step(f0.xyx, f0.yzz); // Makes comparison "less-than"
  vec3 l_ = 1.0 - g_;             // complement is "greater-or-equal"
  vec3 g = vec3(l_.z, g_.xy);
  vec3 l = vec3(l_.xy, g_.z);
  vec3 o1 = min( g, l );
  vec3 o2 = max( g, l );

  // Enumerate the remaining simplex corners
  vec3 i1 = i0 + o1;
  vec3 i2 = i0 + o2;
  vec3 i3 = i0 + vec3(1.0);

  vec3 v0, v1, v2, v3;

  // Transform the corners back to texture space
#ifndef PERLINGRID
  v0 = Mi * i0;
  v1 = Mi * i1;
  v2 = Mi * i2;
  v3 = Mi * i3;
#else
  // Optimised transformation (mostly slightly faster than a matrix)
  v0 = i0 - dot(i0, vec3(1.0/6.0));
  v1 = i1 - dot(i1, vec3(1.0/6.0));
  v2 = i2 - dot(i2, vec3(1.0/6.0));
  v3 = i3 - dot(i3, vec3(1.0/6.0));
#endif

  // Compute vectors to each of the simplex corners
  vec3 x0 = x - v0;
  vec3 x1 = x - v1;
  vec3 x2 = x - v2;
  vec3 x3 = x - v3;

  if(any(greaterThan(period, vec3(0.0)))) {
    // Wrap to periods and transform back to simplex space
    vec4 vx = vec4(v0.x, v1.x, v2.x, v3.x);
    vec4 vy = vec4(v0.y, v1.y, v2.y, v3.y);
    vec4 vz = vec4(v0.z, v1.z, v2.z, v3.z);
	// Wrap to periods where specified
	if(period.x > 0.0) vx = mod(vx, period.x);
	if(period.y > 0.0) vy = mod(vy, period.y);
	if(period.z > 0.0) vz = mod(vz, period.z);
    // Transform back
#ifndef PERLINGRID
    i0 = M * vec3(vx.x, vy.x, vz.x);
    i1 = M * vec3(vx.y, vy.y, vz.y);
    i2 = M * vec3(vx.z, vy.z, vz.z);
    i3 = M * vec3(vx.w, vy.w, vz.w);
#else
    v0 = vec3(vx.x, vy.x, vz.x);
    v1 = vec3(vx.y, vy.y, vz.y);
    v2 = vec3(vx.z, vy.z, vz.z);
    v3 = vec3(vx.w, vy.w, vz.w);
    // Transform wrapped coordinates back to uvw
    i0 = v0 + dot(v0, vec3(1.0/3.0));
    i1 = v1 + dot(v1, vec3(1.0/3.0));
    i2 = v2 + dot(v2, vec3(1.0/3.0));
    i3 = v3 + dot(v3, vec3(1.0/3.0));
#endif
	// Fix rounding errors
    i0 = floor(i0 + 0.5);
    i1 = floor(i1 + 0.5);
    i2 = floor(i2 + 0.5);
    i3 = floor(i3 + 0.5);
  }

  // Compute one pseudo-random hash value for each corner
  vec4 hash = permute( permute( permute( 
              vec4(i0.z, i1.z, i2.z, i3.z ))
            + vec4(i0.y, i1.y, i2.y, i3.y ))
            + vec4(i0.x, i1.x, i2.x, i3.x ));

  // Compute generating gradients from a Fibonacci spiral on the unit sphere
  vec4 theta = hash * 3.883222077;  // 2*pi/golden ratio
  vec4 sz    = hash * -0.006920415 + 0.996539792; // 1-(hash+0.5)*2/289
  vec4 psi   = hash * 0.108705628 ; // 10*pi/289, chosen to avoid correlation

  vec4 Ct = cos(theta);
  vec4 St = sin(theta);
  vec4 sz_prime = sqrt( 1.0 - sz*sz ); // s is a point on a unit fib-sphere

  vec4 gx, gy, gz;

  // Rotate gradients by angle alpha around a pseudo-random ortogonal axis
#ifdef FASTROTATION
  // Fast algorithm, but without dynamic shortcut for alpha = 0
  vec4 qx = St;         // q' = norm ( cross(s, n) )  on the equator
  vec4 qy = -Ct; 
  vec4 qz = vec4(0.0);

  vec4 px =  sz * qy;   // p' = cross(q, s)
  vec4 py = -sz * qx;
  vec4 pz = sz_prime;

  psi += alpha;         // psi and alpha in the same plane
  vec4 Sa = sin(psi);
  vec4 Ca = cos(psi);

  gx = Ca * px + Sa * qx;
  gy = Ca * py + Sa * qy;
  gz = Ca * pz + Sa * qz;
#else
  // Slightly slower algorithm, but with g = s for alpha = 0, and a
  // useful conditional speedup for alpha = 0 across all fragments
  if(alpha != 0.0) {
    vec4 Sp = sin(psi);          // q' from psi on equator
    vec4 Cp = cos(psi);

    vec4 px = Ct * sz_prime;     // px = sx
    vec4 py = St * sz_prime;     // py = sy
    vec4 pz = sz;

    vec4 Ctp = St*Sp - Ct*Cp;    // q = (rotate( cross(s,n), dot(s,n))(q')
    vec4 qx = mix( Ctp*St, Sp, sz);
    vec4 qy = mix(-Ctp*Ct, Cp, sz);
    vec4 qz = -(py*Cp + px*Sp);

    vec4 Sa = vec4(sin(alpha));       // psi and alpha in different planes
    vec4 Ca = vec4(cos(alpha));

    gx = Ca * px + Sa * qx;
    gy = Ca * py + Sa * qy;
    gz = Ca * pz + Sa * qz;
  }
  else {
    gx = Ct * sz_prime;  // alpha = 0, use s directly as gradient
    gy = St * sz_prime;
    gz = sz;  
  }
#endif

  // Reorganize for dot products below
  vec3 g0 = vec3(gx.x, gy.x, gz.x);
  vec3 g1 = vec3(gx.y, gy.y, gz.y);
  vec3 g2 = vec3(gx.z, gy.z, gz.z);
  vec3 g3 = vec3(gx.w, gy.w, gz.w);

  // Radial decay with distance from each simplex corner
  vec4 w = 0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3));
  w = max(w, 0.0);
  vec4 w2 = w * w;
  vec4 w3 = w2 * w;

  // The value of the linear ramp from each of the corners
  vec4 gdotx = vec4(dot(g0,x0), dot(g1,x1), dot(g2,x2), dot(g3,x3));

  // Multiply by the radial decay and sum up the noise value
  float n = dot(w3, gdotx);

  // Compute the first order partial derivatives
  vec4 dw = -6.0 * w2 * gdotx;
  vec3 dn0 = w3.x * g0 + dw.x * x0;
  vec3 dn1 = w3.y * g1 + dw.y * x1;
  vec3 dn2 = w3.z * g2 + dw.z * x2;
  vec3 dn3 = w3.w * g3 + dw.w * x3;
  gradient = 39.5 * (dn0 + dn1 + dn2 + dn3);

  // Scale the return value to fit nicely into the range [-1,1]
  return 39.5 * n;
}

void main()
{
    //FragColor = vec4(abs(fragPos[0]), abs(fragPos[1]), 0.2f, 1.0f);
    vec3 grad;
    vec3 p = vec3(0.0, 0.0, 0.0);
    psrdnoise(fragPos, p, 0.0, grad);
    FragColor = vec4(abs(grad[0]), abs(grad[1]), abs(grad[2]), 1.0f);
}
#version 300 es

layout (location = 0) in vec3 aPos;
out vec3 fragPos;

void main()
{
    gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);
    fragPos = vec3(aPos.x, aPos.y, aPos.z);
}
#version 300 es
precision mediump float;

in vec2 texturePos;
out vec4 velocity;

float N = 100.0; //Grid size in each direction

vec4 permute(vec4 x) {
     vec4 xm = mod(x, 289.0);
     return mod(((xm*34.0)+10.0)*xm, 289.0);
}

float psrdnoise(vec3 x, vec3 period, float alpha, out vec3 gradient)
{

#ifndef PERLINGRID
  // Transformation matrices for the axis-aligned simplex grid
  const mat3 M = mat3(0.0, 1.0, 1.0,
                      1.0, 0.0, 1.0,
                      1.0, 1.0, 0.0);

  const mat3 Mi = mat3(-0.5, 0.5, 0.5,
                        0.5,-0.5, 0.5,
                        0.5, 0.5,-0.5);
#endif

  vec3 uvw;

  // Transform to simplex space (tetrahedral grid)
#ifndef PERLINGRID
  // Use matrix multiplication, let the compiler optimise
  uvw = M * x;
#else
  // Optimised transformation to uvw (slightly faster than
  // the equivalent matrix multiplication on most platforms)
  uvw = x + dot(x, vec3(1.0/3.0));
#endif

  // Determine which simplex we're in, i0 is the "base corner"
  vec3 i0 = floor(uvw);
  vec3 f0 = fract(uvw); // coords within "skewed cube"

  // To determine which simplex corners are closest, rank order the
  // magnitudes of u,v,w, resolving ties in priority order u,v,w,
  // and traverse the four corners from largest to smallest magnitude.
  // o1, o2 are offsets in simplex space to the 2nd and 3rd corners.
  vec3 g_ = step(f0.xyx, f0.yzz); // Makes comparison "less-than"
  vec3 l_ = 1.0 - g_;             // complement is "greater-or-equal"
  vec3 g = vec3(l_.z, g_.xy);
  vec3 l = vec3(l_.xy, g_.z);
  vec3 o1 = min( g, l );
  vec3 o2 = max( g, l );

  // Enumerate the remaining simplex corners
  vec3 i1 = i0 + o1;
  vec3 i2 = i0 + o2;
  vec3 i3 = i0 + vec3(1.0);

  vec3 v0, v1, v2, v3;

  // Transform the corners back to texture space
#ifndef PERLINGRID
  v0 = Mi * i0;
  v1 = Mi * i1;
  v2 = Mi * i2;
  v3 = Mi * i3;
#else
  // Optimised transformation (mostly slightly faster than a matrix)
  v0 = i0 - dot(i0, vec3(1.0/6.0));
  v1 = i1 - dot(i1, vec3(1.0/6.0));
  v2 = i2 - dot(i2, vec3(1.0/6.0));
  v3 = i3 - dot(i3, vec3(1.0/6.0));
#endif

  // Compute vectors to each of the simplex corners
  vec3 x0 = x - v0;
  vec3 x1 = x - v1;
  vec3 x2 = x - v2;
  vec3 x3 = x - v3;

  if(any(greaterThan(period, vec3(0.0)))) {
    // Wrap to periods and transform back to simplex space
    vec4 vx = vec4(v0.x, v1.x, v2.x, v3.x);
    vec4 vy = vec4(v0.y, v1.y, v2.y, v3.y);
    vec4 vz = vec4(v0.z, v1.z, v2.z, v3.z);
	// Wrap to periods where specified
	if(period.x > 0.0) vx = mod(vx, period.x);
	if(period.y > 0.0) vy = mod(vy, period.y);
	if(period.z > 0.0) vz = mod(vz, period.z);
    // Transform back
#ifndef PERLINGRID
    i0 = M * vec3(vx.x, vy.x, vz.x);
    i1 = M * vec3(vx.y, vy.y, vz.y);
    i2 = M * vec3(vx.z, vy.z, vz.z);
    i3 = M * vec3(vx.w, vy.w, vz.w);
#else
    v0 = vec3(vx.x, vy.x, vz.x);
    v1 = vec3(vx.y, vy.y, vz.y);
    v2 = vec3(vx.z, vy.z, vz.z);
    v3 = vec3(vx.w, vy.w, vz.w);
    // Transform wrapped coordinates back to uvw
    i0 = v0 + dot(v0, vec3(1.0/3.0));
    i1 = v1 + dot(v1, vec3(1.0/3.0));
    i2 = v2 + dot(v2, vec3(1.0/3.0));
    i3 = v3 + dot(v3, vec3(1.0/3.0));
#endif
	// Fix rounding errors
    i0 = floor(i0 + 0.5);
    i1 = floor(i1 + 0.5);
    i2 = floor(i2 + 0.5);
    i3 = floor(i3 + 0.5);
  }

  // Compute one pseudo-random hash value for each corner
  vec4 hash = permute( permute( permute( 
              vec4(i0.z, i1.z, i2.z, i3.z ))
            + vec4(i0.y, i1.y, i2.y, i3.y ))
            + vec4(i0.x, i1.x, i2.x, i3.x ));

  // Compute generating gradients from a Fibonacci spiral on the unit sphere
  vec4 theta = hash * 3.883222077;  // 2*pi/golden ratio
  vec4 sz    = hash * -0.006920415 + 0.996539792; // 1-(hash+0.5)*2/289
  vec4 psi   = hash * 0.108705628 ; // 10*pi/289, chosen to avoid correlation

  vec4 Ct = cos(theta);
  vec4 St = sin(theta);
  vec4 sz_prime = sqrt( 1.0 - sz*sz ); // s is a point on a unit fib-sphere

  vec4 gx, gy, gz;

  // Rotate gradients by angle alpha around a pseudo-random ortogonal axis
#ifdef FASTROTATION
  // Fast algorithm, but without dynamic shortcut for alpha = 0
  vec4 qx = St;         // q' = norm ( cross(s, n) )  on the equator
  vec4 qy = -Ct; 
  vec4 qz = vec4(0.0);

  vec4 px =  sz * qy;   // p' = cross(q, s)
  vec4 py = -sz * qx;
  vec4 pz = sz_prime;

  psi += alpha;         // psi and alpha in the same plane
  vec4 Sa = sin(psi);
  vec4 Ca = cos(psi);

  gx = Ca * px + Sa * qx;
  gy = Ca * py + Sa * qy;
  gz = Ca * pz + Sa * qz;
#else
  // Slightly slower algorithm, but with g = s for alpha = 0, and a
  // useful conditional speedup for alpha = 0 across all fragments
  if(alpha != 0.0) {
    vec4 Sp = sin(psi);          // q' from psi on equator
    vec4 Cp = cos(psi);

    vec4 px = Ct * sz_prime;     // px = sx
    vec4 py = St * sz_prime;     // py = sy
    vec4 pz = sz;

    vec4 Ctp = St*Sp - Ct*Cp;    // q = (rotate( cross(s,n), dot(s,n))(q')
    vec4 qx = mix( Ctp*St, Sp, sz);
    vec4 qy = mix(-Ctp*Ct, Cp, sz);
    vec4 qz = -(py*Cp + px*Sp);

    vec4 Sa = vec4(sin(alpha));       // psi and alpha in different planes
    vec4 Ca = vec4(cos(alpha));

    gx = Ca * px + Sa * qx;
    gy = Ca * py + Sa * qy;
    gz = Ca * pz + Sa * qz;
  }
  else {
    gx = Ct * sz_prime;  // alpha = 0, use s directly as gradient
    gy = St * sz_prime;
    gz = sz;  
  }
#endif

  // Reorganize for dot products below
  vec3 g0 = vec3(gx.x, gy.x, gz.x);
  vec3 g1 = vec3(gx.y, gy.y, gz.y);
  vec3 g2 = vec3(gx.z, gy.z, gz.z);
  vec3 g3 = vec3(gx.w, gy.w, gz.w);

  // Radial decay with distance from each simplex corner
  vec4 w = 0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3));
  w = max(w, 0.0);
  vec4 w2 = w * w;
  vec4 w3 = w2 * w;

  // The value of the linear ramp from each of the corners
  vec4 gdotx = vec4(dot(g0,x0), dot(g1,x1), dot(g2,x2), dot(g3,x3));

  // Multiply by the radial decay and sum up the noise value
  float n = dot(w3, gdotx);

  // Compute the first order partial derivatives
  vec4 dw = -6.0 * w2 * gdotx;
  vec3 dn0 = w3.x * g0 + dw.x * x0;
  vec3 dn1 = w3.y * g1 + dw.y * x1;
  vec3 dn2 = w3.z * g2 + dw.z * x2;
  vec3 dn3 = w3.w * g3 + dw.w * x3;
  gradient = 39.5 * (dn0 + dn1 + dn2 + dn3);

  // Scale the return value to fit nicely into the range [-1,1]
  return 39.5 * n;
}

vec3 p1 = vec3(0.0, 0.0, 0.0);
vec3 p2 = vec3(0.0, 0.0, 0.0);
vec3 p3 = vec3(0.0, 0.0, 0.0);    

float fbm(vec3 pos, float alpha, out vec3 grad)
{
    int N = 3;

    vec3 p = vec3(0.0);
    float w = 1.0; //Weight of noise
    float s = 2.0; //Scale of noise
    float n = 0.0; //Output noise value

    vec3 g;
    vec3 gsum = vec3(0.0);

    for(int i = 0; i<N ; i++){
        n += w * psrdnoise(s*pos + 0.13*gsum, p, s*alpha, g);
        gsum += w*g;
        s *= 2.0;
        w *= pow(s,-1.0/3.0);
    }

    grad = gsum;
    return n;

}

vec3 offset2 = vec3(1000.0, 0.0, 0.0);
vec3 offset3 = vec3(0.0, 0.0, 1000.0);

vec3 curlnoise(vec3 pos, float alpha)
{


    vec3 grad1;
    vec3 grad2;
    vec3 grad3;
    float n1 = fbm(pos, alpha, grad1);
    float n2 = fbm(pos+offset2, alpha, grad2);
    float n3 = fbm(pos+offset3, alpha, grad3);

    float w = sqrt(n1*n1 + n2*n2 + n3*n3);

    vec3 velocity = w*vec3((grad3.y-grad2.z),(grad1.z-grad3.x),(grad2.x-grad1.y));

    return velocity;

}

vec3 BoxCoords(vec2 texturecoords){
//Converts between texture coords and spatial coordinates in the box
    float floorFix = 0.000001;
    vec3 boxcoords = vec3(0.0);
    vec2 zFactors = vec2(0.0, 0.0);

    // Goes zero to one every 1/sqrt(N)
    boxcoords.x = mod(texturecoords.x, 1.0/sqrt(N)) * sqrt(N);
    boxcoords.y = mod(texturecoords.y, 1.0/sqrt(N)) * sqrt(N);

    // Bottom to top then left to right
    zFactors.x = floor(texturecoords.x * sqrt(N) + floorFix) * 1.0/sqrt(N);
    zFactors.y = floor(texturecoords.y * sqrt(N) + floorFix) * 1.0/N;

    boxcoords.z = zFactors.x + zFactors.y;
    return 2.0*boxcoords-1.0;
}

void main(){
    vec3 boxpos = BoxCoords(texturePos); //Convert to position in box space
    float scale = 0.01;
    velocity = vec4(scale*curlnoise(boxpos, 0.0), 1.0); //Calculate the velocity field at this point 
    // velocity = vec4(texturePos.x, texturePos.y, 1.0, 1.0);
}
#version 300 es
layout(location = 0) in vec3 inPos;

out vec2 texturePos;

void main()
{
    gl_Position = vec4(inPos, 1.0);
    texturePos = (inPos.xy + vec2(1.0)) / 2.0;
}
